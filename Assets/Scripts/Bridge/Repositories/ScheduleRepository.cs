using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using System.IO;
using GG.Bridge.Dto;
using GG.Bridge.Validation;
using GG.Infra;

namespace GG.Bridge.Repositories
{
    public static class ScheduleRepository
    {
        private const string DefaultPath = "schedule.json"; // under /data
        public static ScheduleDTO Current { get; private set; }

        public static bool TryLoad(out string absPath)
        {
            absPath = null;
            try
            {
                Current = DataIO.LoadJson<ScheduleDTO>(DefaultPath);
                absPath = ResolvePath(DefaultPath);
                if (Current.ApiVersion != "gg.v1") throw new Exception("bad api_version");
                return true;
            }
            catch (Exception ex)
            {
                GGLog.Warn($"Schedule load failed ({ex.Message}).");
                return false;
            }
        }

        public static void AutoGenerateIfMissing(IReadOnlyList<string> teamAbbrs, int year)
        {
            if (Current != null) return;
            // Minimal 4-week round-robin-ish so UI and sim work
            var teams = teamAbbrs.ToList();
            if (teams.Count < 2) throw new Exception("Need >= 2 teams to build schedule.");

            var weeks = new List<WeekDTO>();
            int week = 1;
            for (int i = 0; i < teams.Count - 1 && week <= 4; i++, week++)
            {
                var games = new List<GameDTO>();
                for (int a = 0; a < teams.Count; a += 2)
                {
                    var home = teams[a];
                    var away = teams[(a + 1) % teams.Count];
                    if (home == away) continue;
                    games.Add(new GameDTO {
                        GameId = $"{year}-W{week}-{home}-{away}",
                        Home = home, Away = away, Played = false,
                        Score = new Dictionary<string,int>{{home,0},{away,0}}
                    });
                }
                weeks.Add(new WeekDTO { Week = week, Games = games });
                // rotate away team list for variety
                var first = teams[1];
                teams.RemoveAt(1);
                teams.Add(first);
            }

            Current = new ScheduleDTO { ApiVersion = "gg.v1", Year = year, Weeks = weeks };
            Save(DefaultPath);
            GGLog.Info($"Autogenerated schedule with {weeks.Count} weeks.");
        }

        public static int CurrentWeekIndex()
        {
            if (Current == null) return 0;
            for (int i = 0; i < Current.Weeks.Count; i++)
                if (Current.Weeks[i].Games.Exists(g => !g.Played)) return i;
            return Current.Weeks.Count - 1;
        }

        public static bool HasUnplayedThisWeek(string teamAbbr, out GameDTO nextGame)
        {
            nextGame = null;
            if (Current == null) return false;
            var w = Current.Weeks[CurrentWeekIndex()];
            nextGame = w.Games.FirstOrDefault(g => !g.Played && (g.Home == teamAbbr || g.Away == teamAbbr));
            return nextGame != null;
        }

        public static void SimNextGameForTeam(string teamAbbr)
        {
            if (!HasUnplayedThisWeek(teamAbbr, out var game)) return;
            var rnd = new Random(Environment.TickCount);
            var homePts = rnd.Next(10, 40);
            var awayPts = rnd.Next(10, 40);
            game.Score[game.Home] = homePts;
            game.Score[game.Away] = awayPts;
            game.Played = true;
            Save(DefaultPath);
        }

        public static void SimEntireWeek()
        {
            if (Current == null) return;
            var w = Current.Weeks[CurrentWeekIndex()];
            var rnd = new Random(Environment.TickCount);
            foreach (var g in w.Games.Where(g => !g.Played))
            {
                g.Score[g.Home] = rnd.Next(10, 40);
                g.Score[g.Away] = rnd.Next(10, 40);
                g.Played = true;
            }
            Save(DefaultPath);
        }

        public static void Save(string relativePath)
        {
            var abs = ResolvePath(relativePath);
            Directory.CreateDirectory(Path.GetDirectoryName(abs));
            var json = JsonConvert.SerializeObject(Current, Formatting.Indented);
            File.WriteAllText(abs, json);
            GGLog.Info($"Saved schedule to {abs}");
        }

        private static string ResolvePath(string relative) =>
            Path.GetFullPath(Path.Combine(System.IO.Path.Combine(UnityEngine.Application.dataPath, "..", "data"), relative));
    }
}
