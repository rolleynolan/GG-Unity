using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using GG.Bridge.Dto;

namespace GG.Bridge.Repositories
{
    public static class ScheduleRepository
    {
        public static ScheduleDTO Current { get; private set; }

        public static bool TryLoad(out string absPath)
        {
            absPath = GGPaths.ScheduleFile();
            if (!File.Exists(absPath))
            {
                GGLog.Warn($"ScheduleRepository: file not found at {absPath}");
                return false;
            }

            try
            {
                var json = File.ReadAllText(absPath);
                Current = JsonUtility.FromJson<ScheduleDTO>(json);
                if (Current == null || Current.api_version != "gg.v1")
                    throw new Exception("bad schedule data");
                GGLog.Info("ScheduleRepository: schedule loaded.");
                return true;
            }
            catch (Exception ex)
            {
                GGLog.Warn($"ScheduleRepository: load failed ({ex.Message}).");
                Current = null;
                return false;
            }
        }

        public static void AutoGenerateIfMissing(List<string> teamAbbrs, int year)
        {
            if (Current != null) return;
            var teams = new List<string>(teamAbbrs);
            if (teams.Count < 2) teams.AddRange(new[] { "ATL", "PHI" });

            var weeks = new List<WeekDTO>();
            int weekNum = 1;
            for (int w = 0; w < Math.Min(3, teams.Count); w++, weekNum++)
            {
                var week = new WeekDTO { week = weekNum };
                for (int i = 0; i + 1 < teams.Count; i += 2)
                {
                    var home = teams[i];
                    var away = teams[i + 1];
                    week.games.Add(new GameDTO
                    {
                        game_id = $"{year}-W{weekNum}-{home}-{away}",
                        home = home,
                        away = away,
                        played = false,
                        homePts = 0,
                        awayPts = 0
                    });
                }
                weeks.Add(week);
                var first = teams[1];
                teams.RemoveAt(1);
                teams.Add(first);
            }

            Current = new ScheduleDTO { api_version = "gg.v1", year = year, weeks = weeks };
            Save();
            GGLog.Info($"ScheduleRepository: autogenerated schedule with {weeks.Count} weeks.");
        }

        public static int CurrentWeekIndex()
        {
            if (Current == null || Current.weeks.Count == 0) return 0;
            for (int i = 0; i < Current.weeks.Count; i++)
                if (Current.weeks[i].games.Exists(g => !g.played)) return i;
            return Current.weeks.Count - 1;
        }

        public static bool HasUnplayedThisWeek(string teamAbbr, out GameDTO nextGame)
        {
            nextGame = null;
            if (Current == null) return false;
            var w = Current.weeks[CurrentWeekIndex()];
            nextGame = w.games.Find(g => !g.played && (g.home == teamAbbr || g.away == teamAbbr));
            return nextGame != null;
        }

        public static void SimNextGameForTeam(string teamAbbr)
        {
            if (!HasUnplayedThisWeek(teamAbbr, out var g)) return;
            var rnd = new System.Random(Environment.TickCount);
            g.homePts = rnd.Next(10, 40);
            g.awayPts = rnd.Next(10, 40);
            g.played = true;
            Save();
        }

        public static void SimEntireWeek()
        {
            if (Current == null) return;
            var rnd = new System.Random(Environment.TickCount);
            var w = Current.weeks[CurrentWeekIndex()];
            foreach (var g in w.games)
            {
                if (g.played) continue;
                g.homePts = rnd.Next(10, 40);
                g.awayPts = rnd.Next(10, 40);
                g.played = true;
            }
            Save();
        }

        public static void Save()
        {
            var abs = GGPaths.ScheduleFile();
            var json = JsonUtility.ToJson(Current, true);
            File.WriteAllText(abs, json);
            GGLog.Info($"ScheduleRepository: saved schedule to {abs}");
        }
    }
}
